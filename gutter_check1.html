<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>gutter_check</title>
<meta name="generator" content="MATLAB 25.2" />
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.date" content="2025-11-24" />
<meta name="DC.source" content="gutter_check.m" />
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body data-mwthemeclass-status="false" class="mw-theme-light" style="zoom: 100%;">
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">WATER_RETAINING_WALL_CSA</a>
</li>
<li>
<a href="#2">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#3">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#4">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#5">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#6">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#7">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#8">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#9">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#10">-------------------------------------------------------------------------</a>
</li>
<li>
<a href="#11">--- MOMENT CHECK ---</a>
</li>
<li>
<a href="#12">--- SHEAR CHECK ---</a>
</li>
<li>
<a href="#13">--- DEFLECTION CHECK ---</a>
</li>
<li>
<a href="#14">-------------------------------------------------------------------------</a>
</li>
</ul>
</div>
<h2 id="1">WATER_RETAINING_WALL_CSA</h2>
<p>CSA-based stability analysis for a water-retaining wall section. Checks overturning, sliding, and bearing capacity for the supplied geometry and hydrostatic loading. All forces are reported per metre length of wall.</p>
<p>Coordinate system: toe edge at x = 0, positive x runs toward the heel. Several geometric values (e.g., stem and base thickness) are assumed and should be updated if project-specific data are available.</p>
<pre class="codeinput">clear; close <span class="string">all</span>; clc;

mm = 1e-3;
</pre>
<h2 id="2">-------------------------------------------------------------------------</h2>
<pre>INPUT PARAMETERS
-------------------------------------------------------------------------</pre>
<pre class="codeinput"><span class="comment">% Geometry (metres unless noted)</span>
geom.stemHeight = 3050 * mm;
geom.heelWidth  = 1300 * mm;
geom.toeWidth   = 610  * mm;
geom.stemThk    = 0.35;         <span class="comment">% average constant thickness</span>
geom.baseThk    = 0.4;         <span class="comment">% footing thickness</span>
geom.keyWidth   = 350  * mm;
geom.keyDepth   = 370  * mm;

geom.gutter.offsetBelowTop = 400 * mm;
geom.gutter.horizWidth     = 1000 * mm;
geom.gutter.horizThk       = 150 * mm;
geom.gutter.vertHeight     = 290 * mm;
geom.gutter.vertThk        = 150 * mm;

geom.roof.thk           = 250 * mm;
geom.roof.tributarySpan = 3.0; <span class="comment">% m</span>

<span class="comment">% Optional heel floor slab weight (set thickness &gt; 0 to include)</span>
geom.floorSlabThk   = 0.0;      <span class="comment">% m</span>
geom.floorSlabWidth = geom.heelWidth;

<span class="comment">% Hydrostatic loading</span>
loads.waterDepth = 0.0 * mm;   <span class="comment">% measured from heel slab surface</span>

<span class="comment">% Material properties</span>
mat.gammaConcrete = 25.0;       <span class="comment">% kN/m^3</span>
mat.gammaWater    = 9.81;       <span class="comment">% kN/m^3</span>
mat.gammaSoil     = 19.0;       <span class="comment">% kN/m^3</span>
mat.phi           = deg2rad(31);
mat.delta         = deg2rad(15);

<span class="comment">% CSA target factors of safety(temporary works)</span>
criteria.overturning = 1.20;
criteria.sliding     = 1.20;
criteria.bearing     = 2.0;

ls.phi_bearing = 0.5;
ls.gamma_dead  = 1.25;
ls.gamma_hydro = 1.00;
</pre>
<h2 id="3">-------------------------------------------------------------------------</h2>
<pre>DERIVED GEOMETRY
-------------------------------------------------------------------------</pre>
<pre class="codeinput">geom.baseWidth        = geom.toeWidth + geom.heelWidth + geom.stemThk;
geom.stemCL           = geom.toeWidth + geom.stemThk/2;
geom.baseTopElevation = geom.baseThk;
geom.stemLeft         = geom.stemCL - geom.stemThk/2;
geom.stemRight        = geom.stemCL + geom.stemThk/2;
</pre>
<h2 id="4">-------------------------------------------------------------------------</h2>
<pre>GRAVITY LOAD COMPONENTS
-------------------------------------------------------------------------</pre>
<pre class="codeinput">components = struct(<span class="string">'Name'</span>, {}, <span class="string">'Weight'</span>, {}, <span class="string">'LeverArm'</span>, {}, <span class="string">'Moment'</span>, {}, <span class="string">'Notes'</span>, {});

components = addComponent(components, <span class="string">"Base slab"</span>, <span class="keyword">...</span>
    mat.gammaConcrete * geom.baseWidth * geom.baseThk, geom.baseWidth / 2, <span class="keyword">...</span>
    <span class="string">"Footing self-weight"</span>);

components = addComponent(components, <span class="string">"Shear key"</span>, <span class="keyword">...</span>
    mat.gammaConcrete * geom.keyWidth * geom.keyDepth, geom.stemCL, <span class="keyword">...</span>
    <span class="string">"Key volume below footing"</span>);

components = addComponent(components, <span class="string">"Stem"</span>, <span class="keyword">...</span>
    mat.gammaConcrete * geom.stemThk * geom.stemHeight, geom.stemCL, <span class="keyword">...</span>
    <span class="string">"Rectangular stem"</span>);

components = addComponent(components, <span class="string">"Gutter (horizontal)"</span>, <span class="keyword">...</span>
    mat.gammaConcrete * geom.gutter.horizWidth * geom.gutter.horizThk, <span class="keyword">...</span>
    geom.stemCL - geom.gutter.horizWidth / 2, <span class="keyword">...</span>
    <span class="string">"Toe-side gutter slab"</span>);

components = addComponent(components, <span class="string">"Gutter (vertical)"</span>, <span class="keyword">...</span>
    mat.gammaConcrete * geom.gutter.vertHeight * geom.gutter.vertThk, <span class="keyword">...</span>
    geom.stemCL - geom.gutter.horizWidth + geom.gutter.vertThk / 2, <span class="keyword">...</span>
    <span class="string">"Toe-side curb"</span>);

components = addComponent(components, <span class="string">"Roof slab tributary load"</span>, <span class="keyword">...</span>
    mat.gammaConcrete * geom.roof.thk * geom.roof.tributarySpan, geom.stemCL, <span class="keyword">...</span>
    <span class="string">"Roof weight carried by stem"</span>);

<span class="keyword">if</span> geom.floorSlabThk &gt; 0
    components = addComponent(components, <span class="string">"Heel floor slab (optional)"</span>, <span class="keyword">...</span>
        mat.gammaConcrete * geom.floorSlabThk * geom.floorSlabWidth, <span class="keyword">...</span>
        geom.stemCL + geom.heelWidth / 2, <span class="keyword">...</span>
        <span class="string">"Adjust thickness if present"</span>);
<span class="keyword">end</span>

weights     = [components.Weight]';
leverArms   = [components.LeverArm]';
moments     = [components.Moment]';

W_total     = sum(weights);
M_resisting = sum(moments);
</pre>
<h2 id="5">-------------------------------------------------------------------------</h2>
<pre>HYDROSTATIC ACTIONS
-------------------------------------------------------------------------</pre>
<pre class="codeinput">hydro.thrust = 0.5 * mat.gammaWater * loads.waterDepth^2;            <span class="comment">% kN/m</span>
hydro.arm    = geom.baseTopElevation + loads.waterDepth / 3;          <span class="comment">% m</span>
hydro.moment = hydro.thrust * hydro.arm;                              <span class="comment">% kN·m/m</span>

V_net = W_total;                                                       <span class="comment">% kN/m (downwards positive)</span>
</pre>
<h2 id="6">-------------------------------------------------------------------------</h2>
<pre>STABILITY CHECKS (CSA)
-------------------------------------------------------------------------</pre>
<pre class="codeinput">FS_overturning = M_resisting / hydro.moment;

friction_resistance = V_net * tan(mat.delta);
Kp = tan(pi/4 + mat.phi/2)^2;
passive_resistance = 0.5 * Kp * mat.gammaSoil * geom.keyDepth^2 * geom.keyWidth;

FS_sliding = (friction_resistance + passive_resistance) / hydro.thrust;

M_net_about_toe = M_resisting - hydro.moment;

<span class="keyword">if</span> V_net &lt;= 0
    warning(<span class="string">'Net vertical load is non-positive. Sliding and bearing checks are invalid.'</span>);
    x_resultant  = NaN;
    eccentricity = NaN;
    q_avg        = NaN;
    q_toe        = NaN;
    q_heel       = NaN;
<span class="keyword">else</span>
    x_resultant  = M_net_about_toe / V_net;                  <span class="comment">% m from toe</span>
    eccentricity = geom.baseWidth / 2 - x_resultant;         <span class="comment">% +ve toward toe</span>
    q_avg        = V_net / geom.baseWidth;                   <span class="comment">% kPa</span>
    q_toe        = q_avg * (1 + 6 * eccentricity / geom.baseWidth);
    q_heel       = q_avg * (1 - 6 * eccentricity / geom.baseWidth);
<span class="keyword">end</span>

W_uls              = ls.gamma_dead * W_total;
M_resisting_uls    = ls.gamma_dead * M_resisting;
hydro_uls.thrust   = ls.gamma_hydro * hydro.thrust;
hydro_uls.moment   = ls.gamma_hydro * hydro.moment;
V_net_uls          = W_uls;
M_net_about_toe_uls = M_resisting_uls - hydro_uls.moment;

<span class="keyword">if</span> V_net_uls &lt;= 0
    x_resultant_uls  = NaN;
    eccentricity_uls = NaN;
    q_avg_uls        = NaN;
    q_toe_uls        = NaN;
    q_heel_uls       = NaN;
<span class="keyword">else</span>
    x_resultant_uls  = M_net_about_toe_uls / V_net_uls;
    eccentricity_uls = geom.baseWidth / 2 - x_resultant_uls;
    q_avg_uls        = V_net_uls / geom.baseWidth;
    q_toe_uls        = q_avg_uls * (1 + 6 * eccentricity_uls / geom.baseWidth);
    q_heel_uls       = q_avg_uls * (1 - 6 * eccentricity_uls / geom.baseWidth);
<span class="keyword">end</span>

q_pair = [q_toe, q_heel];
valid_q = q_pair(~isnan(q_pair));
<span class="keyword">if</span> isempty(valid_q)
    q_max = NaN;
    q_min = NaN;
<span class="keyword">else</span>
    q_max = max(valid_q);
    q_min = min(valid_q);
<span class="keyword">end</span>

Nq     = exp(pi * tan(mat.phi)) * tan(pi/4 + mat.phi/2)^2;
Ngamma = 2 * (Nq + 1) * tan(mat.phi);

<span class="comment">% ULS effective width method (CFEM): no-tension, use B_eff = B - 2|e_uls|</span>
<span class="keyword">if</span> isnan(eccentricity_uls)
    B_eff_uls = NaN;
    q_dem_uls = NaN;
    phi_q_ult = NaN;
<span class="keyword">else</span>
    B_eff_uls = max(geom.baseWidth - 2 * abs(eccentricity_uls), 1e-6);
    q_ult_eff = 0.5 * mat.gammaSoil * B_eff_uls * Ngamma;   <span class="comment">% kPa</span>
    phi_q_ult = ls.phi_bearing * q_ult_eff;                 <span class="comment">% kPa</span>
    q_dem_uls = V_net_uls / B_eff_uls;                      <span class="comment">% kPa</span>
<span class="keyword">end</span>

<span class="comment">% Also report ULS linear pressures (may show tension if e_uls &gt; B/6)</span>
<span class="keyword">if</span> isnan(q_toe_uls) || isnan(q_heel_uls)
    q_max_uls = NaN;
    q_min_uls = NaN;
<span class="keyword">else</span>
    q_max_uls = max([q_toe_uls, q_heel_uls]);
    q_min_uls = min([q_toe_uls, q_heel_uls]);
<span class="keyword">end</span>

<span class="keyword">if</span> isnan(q_dem_uls) || q_dem_uls &lt;= 0
    FS_bearing = NaN;
<span class="keyword">else</span>
    FS_bearing = phi_q_ult / q_dem_uls;
<span class="keyword">end</span>

<span class="keyword">if</span> isnan(eccentricity)
    within_middle_third = false;
<span class="keyword">else</span>
    within_middle_third = abs(eccentricity) &lt;= geom.baseWidth / 6;
<span class="keyword">end</span>
</pre>
<h2 id="7">-------------------------------------------------------------------------</h2>
<pre>TABULATED RESULTS
-------------------------------------------------------------------------</pre>
<pre class="codeinput">componentTable = table(string({components.Name})', weights, leverArms, moments, string({components.Notes})', <span class="keyword">...</span>
    <span class="string">'VariableNames'</span>, {<span class="string">'Component'</span>, <span class="string">'Weight_kN_per_m'</span>, <span class="string">'LeverArm_m'</span>, <span class="string">'Moment_kNm_per_m'</span>, <span class="string">'Notes'</span>});

FS_values   = [FS_overturning; FS_sliding; FS_bearing];
FS_required = [criteria.overturning; criteria.sliding; 1.0];
statusStr   = repmat(<span class="string">"PASS"</span>, size(FS_values));
statusStr(FS_values &lt; FS_required) = <span class="string">"CHECK"</span>;

resultsTable = table([<span class="string">"Overturning"</span>; <span class="string">"Sliding"</span>; <span class="string">"Bearing"</span>], FS_values, FS_required, statusStr, <span class="keyword">...</span>
    <span class="string">'VariableNames'</span>, {<span class="string">'Check'</span>, <span class="string">'FS_Computed'</span>, <span class="string">'FS_Required'</span>, <span class="string">'Status'</span>});

bearingTable = table(q_toe, q_heel, q_avg, q_min, q_max, q_toe_uls, q_heel_uls, q_max_uls, B_eff_uls, q_dem_uls, phi_q_ult, within_middle_third, <span class="keyword">...</span>
    <span class="string">'VariableNames'</span>, {<span class="string">'q_toe_SLS_kPa'</span>, <span class="string">'q_heel_SLS_kPa'</span>, <span class="string">'q_avg_SLS_kPa'</span>, <span class="string">'q_min_SLS_kPa'</span>, <span class="string">'q_max_SLS_kPa'</span>, <span class="keyword">...</span>
                      <span class="string">'q_toe_ULS_kPa'</span>, <span class="string">'q_heel_ULS_kPa'</span>, <span class="string">'q_max_ULS_kPa'</span>, <span class="string">'B_eff_ULS_m'</span>, <span class="string">'q_dem_ULS_kPa'</span>, <span class="string">'phi_q_ult_kPa'</span>, <span class="string">'WithinMiddleThird'</span>});
</pre>
<h2 id="8">-------------------------------------------------------------------------</h2>
<pre>CONSOLE OUTPUT
-------------------------------------------------------------------------</pre>
<pre class="codeinput">fprintf(<span class="string">'\nCSA Water-Retaining Wall Stability Check (per metre length)\n'</span>);
fprintf(<span class="string">'-----------------------------------------------------------\n'</span>);
fprintf(<span class="string">'Toe width                : %.3f m\n'</span>, geom.toeWidth);
fprintf(<span class="string">'Heel width               : %.3f m\n'</span>, geom.heelWidth);
fprintf(<span class="string">'Overall base width       : %.3f m\n'</span>, geom.baseWidth);
fprintf(<span class="string">'Stem height              : %.3f m\n'</span>, geom.stemHeight);
fprintf(<span class="string">'Water depth at heel      : %.3f m\n'</span>, loads.waterDepth);
fprintf(<span class="string">'Assumed base thickness   : %.0f mm\n'</span>, geom.baseThk * 1e3);
fprintf(<span class="string">'Assumed stem thickness   : %.0f mm\n\n'</span>, geom.stemThk * 1e3);

fprintf(<span class="string">'Total dead load          : %.2f kN/m\n'</span>, W_total);
fprintf(<span class="string">'Hydrostatic thrust       : %.2f kN/m\n'</span>, hydro.thrust);
fprintf(<span class="string">'Net vertical load        : %.2f kN/m\n\n'</span>, V_net);

disp(componentTable);

fprintf(<span class="string">'Stability Factors of Safety\n'</span>);
fprintf(<span class="string">'---------------------------\n'</span>);
disp(resultsTable);

fprintf(<span class="string">'Bearing summary (toe positive)\n'</span>);
fprintf(<span class="string">'-------------------------------\n'</span>);
disp(bearingTable);

fprintf(<span class="string">'Resultant from toe        : %.3f m\n'</span>, x_resultant);
fprintf(<span class="string">'Eccentricity (toe +ve)    : %.3f m (limit %.3f m)\n'</span>, eccentricity, geom.baseWidth/6);

<span class="keyword">if</span> FS_overturning &lt; criteria.overturning
    fprintf(<span class="string">'WARNING: Overturning FS below CSA minimum (%.2f &lt; %.2f).\n'</span>, FS_overturning, criteria.overturning);
<span class="keyword">end</span>
<span class="keyword">if</span> FS_sliding &lt; criteria.sliding
    fprintf(<span class="string">'WARNING: Sliding FS below CSA minimum (%.2f &lt; %.2f).\n'</span>, FS_sliding, criteria.sliding);
<span class="keyword">end</span>
<span class="keyword">if</span> FS_bearing &lt; 1.0
    fprintf(<span class="string">'WARNING: Bearing ULS check not satisfied (FS = %.2f &lt; 1.00). Factored demand exceeds factored resistance.\n'</span>, FS_bearing);
<span class="keyword">end</span>
<span class="keyword">if</span> ~within_middle_third
    fprintf(<span class="string">'WARNING: Resultant lies outside the middle third; heel tension likely.\n'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isnan(q_min) &amp;&amp; q_min &lt; 0
    fprintf(<span class="string">'WARNING: Heel contact pressure negative (q_{min} = %.2f kPa). Revise geometry/loading.\n'</span>, q_min);
<span class="keyword">end</span>
</pre>
<pre class="codeoutput">CSA Water-Retaining Wall Stability Check (per metre length)
-----------------------------------------------------------
Toe width                : 0.610 m
Heel width               : 1.300 m
Overall base width       : 2.260 m
Stem height              : 3.050 m
Water depth at heel      : 0.000 m
Assumed base thickness   : 400 mm
Assumed stem thickness   : 350 mm

Total dead load          : 76.11 kN/m
Hydrostatic thrust       : 0.00 kN/m
Net vertical load        : 76.11 kN/m

            Component             Weight_kN_per_m    LeverArm_m    Moment_kNm_per_m                Notes            
    __________________________    _______________    __________    ________________    _____________________________

    "Base slab"                         22.6            1.13             25.538        "Footing self-weight"        
    "Shear key"                       3.2375           0.785             2.5414        "Key volume below footing"   
    "Stem"                            26.688           0.785              20.95        "Rectangular stem"           
    "Gutter (horizontal)"               3.75           0.285             1.0687        "Toe-side gutter slab"       
    "Gutter (vertical)"               1.0875           -0.14           -0.15225        "Toe-side curb"              
    "Roof slab tributary load"         18.75           0.785             14.719        "Roof weight carried by stem"

Stability Factors of Safety
---------------------------
        Check        FS_Computed    FS_Required    Status
    _____________    ___________    ___________    ______

    "Overturning"         Inf           1.2        "PASS"
    "Sliding"             Inf           1.2        "PASS"
    "Bearing"           3.747             1        "PASS"

Bearing summary (toe positive)
-------------------------------
    q_toe_SLS_kPa    q_heel_SLS_kPa    q_avg_SLS_kPa    q_min_SLS_kPa    q_max_SLS_kPa    q_toe_ULS_kPa    q_heel_ULS_kPa    q_max_ULS_kPa    B_eff_ULS_m    q_dem_ULS_kPa    phi_q_ult_kPa    WithinMiddleThird
    _____________    ______________    _____________    _____________    _____________    _____________    ______________    _____________    ___________    _____________    _____________    _________________

        58.75            8.6063           33.678           8.6063            58.75           73.437            10.758           73.437          1.6992          55.992            209.8              true       

Resultant from toe        : 0.850 m
Eccentricity (toe +ve)    : 0.280 m (limit 0.377 m)
</pre>
<h2 id="9">-------------------------------------------------------------------------</h2>
<pre>VISUALISATIONS
-------------------------------------------------------------------------</pre>
<pre class="codeinput">figure(<span class="string">'Name'</span>, <span class="string">'Wall Geometry &amp; Hydrostatics'</span>, <span class="string">'Color'</span>, <span class="string">'w'</span>);
hold <span class="string">on</span>; axis <span class="string">equal</span>;

<span class="comment">% Base slab</span>
basePoly = [0, 0;
            geom.baseWidth, 0;
            geom.baseWidth, geom.baseTopElevation;
            0, geom.baseTopElevation];
patch(basePoly(:,1), basePoly(:,2), [0.85 0.85 0.88], <span class="string">'EdgeColor'</span>, <span class="string">'k'</span>);

<span class="comment">% Shear key</span>
keyLeft  = geom.stemCL - geom.keyWidth/2;
keyRight = geom.stemCL + geom.keyWidth/2;
keyPoly = [keyLeft, 0;
           keyRight, 0;
           keyRight, -geom.keyDepth;
           keyLeft, -geom.keyDepth];
patch(keyPoly(:,1), keyPoly(:,2), [0.75 0.75 0.80], <span class="string">'EdgeColor'</span>, <span class="string">'k'</span>);

<span class="comment">% Stem</span>
stemPoly = [geom.stemLeft,  geom.baseTopElevation;
            geom.stemRight, geom.baseTopElevation;
            geom.stemRight, geom.baseTopElevation + geom.stemHeight;
            geom.stemLeft,  geom.baseTopElevation + geom.stemHeight];
patch(stemPoly(:,1), stemPoly(:,2), [0.90 0.90 0.94], <span class="string">'EdgeColor'</span>, <span class="string">'k'</span>);

<span class="comment">% Gutter horizontal slab (toe side)</span>
gutterTop    = geom.baseTopElevation + geom.stemHeight - geom.gutter.offsetBelowTop;
gutterBottom = gutterTop - geom.gutter.horizThk;
gutterLeft   = geom.stemCL - geom.gutter.horizWidth;
gutterRight  = geom.stemCL;
gutterHPoly  = [gutterLeft, gutterBottom;
                gutterRight, gutterBottom;
                gutterRight, gutterTop;
                gutterLeft, gutterTop];
patch(gutterHPoly(:,1), gutterHPoly(:,2), [0.80 0.88 0.90], <span class="string">'EdgeColor'</span>, <span class="string">'k'</span>);

<span class="comment">% Gutter vertical curb</span>
curbBottom = gutterTop;
curbTop    = gutterTop + geom.gutter.vertHeight;
curbLeft   = gutterLeft;
curbRight  = gutterLeft + geom.gutter.vertThk;
curbPoly   = [curbLeft, curbBottom;
              curbRight, curbBottom;
              curbRight, curbTop;
              curbLeft, curbTop];
patch(curbPoly(:,1), curbPoly(:,2), [0.78 0.86 0.88], <span class="string">'EdgeColor'</span>, <span class="string">'k'</span>);

<span class="comment">% Water retained on heel side</span>
waterTop = geom.baseTopElevation + loads.waterDepth;
waterPoly = [geom.stemRight,           geom.baseTopElevation;
             geom.stemRight,           waterTop;
             geom.stemRight + 0.35,    waterTop;
             geom.stemRight + 0.35,    geom.baseTopElevation];
patch(waterPoly(:,1), waterPoly(:,2), [0.70 0.80 0.95], <span class="string">'FaceAlpha'</span>, 0.6, <span class="string">'EdgeColor'</span>, [0.3 0.4 0.7]);

<span class="comment">% Hydrostatic pressure diagram</span>
pressureScale = 0.012; <span class="comment">% m per kPa for plotting</span>
pressureAtBase = mat.gammaWater * loads.waterDepth;
pressurePoly = [geom.stemRight,                               geom.baseTopElevation;
                geom.stemRight + pressureAtBase * pressureScale, geom.baseTopElevation;
                geom.stemRight,                               waterTop];
patch(pressurePoly(:,1), pressurePoly(:,2), [0.40 0.55 0.90], <span class="string">'FaceAlpha'</span>, 0.35, <span class="string">'EdgeColor'</span>, <span class="string">'none'</span>);
plot([geom.stemRight, geom.stemRight], [geom.baseTopElevation, waterTop], <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 1.2);

<span class="comment">% Resultant location marker</span>
<span class="keyword">if</span> ~isnan(x_resultant)
    plot([x_resultant, x_resultant], [-geom.keyDepth, geom.baseTopElevation], <span class="string">'r--'</span>, <span class="string">'LineWidth'</span>, 1.2);
    text(x_resultant, -geom.keyDepth - 0.05, sprintf(<span class="string">'Resultant %.3f m from toe'</span>, x_resultant), <span class="keyword">...</span>
        <span class="string">'Color'</span>, <span class="string">'r'</span>, <span class="string">'HorizontalAlignment'</span>, <span class="string">'center'</span>);
<span class="keyword">end</span>

title(<span class="string">'Wall Elevation &amp; Hydrostatic Actions'</span>);
xlabel(<span class="string">'Horizontal distance from toe (m)'</span>);
ylabel(<span class="string">'Elevation (m)'</span>);
grid <span class="string">on</span>;
xlim([gutterLeft - 0.4, geom.baseWidth + 0.5]);
ylim([-geom.keyDepth - 0.2, geom.baseTopElevation + geom.stemHeight + 0.4]);

<span class="comment">% Stability summary plots -------------------------------------------------</span>
figure(<span class="string">'Name'</span>, <span class="string">'CSA Stability Summary'</span>, <span class="string">'Color'</span>, <span class="string">'w'</span>);
tl = tiledlayout(1,2, <span class="string">'TileSpacing'</span>, <span class="string">'compact'</span>, <span class="string">'Padding'</span>, <span class="string">'compact'</span>);

<span class="comment">% Factors of safety bar chart</span>
nexttile(tl, 1);
barData = [FS_values FS_required];
hb = bar(1:3, barData, <span class="string">'grouped'</span>);
hb(1).FaceColor = [0.55 0.75 0.55];
hb(2).FaceColor = [0.85 0.60 0.60];
hold <span class="string">on</span>; grid <span class="string">on</span>;

<span class="keyword">for</span> k = 1:numel(hb)
    xPts = hb(k).XEndPoints;
    yVals = hb(k).YData;
    <span class="keyword">for</span> j = 1:numel(xPts)
        <span class="keyword">switch</span> k
            <span class="keyword">case</span> 1
                labelText = sprintf(<span class="string">'%.2f'</span>, yVals(j));
                labelColor = [0 0 0];
                labelWeight = <span class="string">'bold'</span>;
            <span class="keyword">case</span> 2
                labelText = sprintf(<span class="string">'Req %.2f'</span>, yVals(j));
                labelColor = [0.6 0.1 0.1];
                labelWeight = <span class="string">'normal'</span>;
        <span class="keyword">end</span>
        text(xPts(j), yVals(j) + 0.05, labelText, <span class="string">'HorizontalAlignment'</span>, <span class="string">'center'</span>, <span class="keyword">...</span>
            <span class="string">'Color'</span>, labelColor, <span class="string">'FontWeight'</span>, labelWeight);
    <span class="keyword">end</span>
<span class="keyword">end</span>

set(gca, <span class="string">'XTick'</span>, 1:3, <span class="string">'XTickLabel'</span>, resultsTable.Check);
ylabel(<span class="string">'Factor of Safety'</span>);
title(<span class="string">'Factors of Safety vs CSA Targets'</span>);
legend({<span class="string">'Computed FS'</span>, <span class="string">'CSA Target'</span>}, <span class="string">'Location'</span>, <span class="string">'northwest'</span>);

<span class="comment">% Bearing pressure profile</span>
nexttile(tl, 2);
hold <span class="string">on</span>; grid <span class="string">on</span>;

<span class="keyword">if</span> all(isnan(q_pair))
    q_plot = [0, 0];
<span class="keyword">else</span>
    q_plot = [q_toe, q_heel];
<span class="keyword">end</span>

plot([0, geom.baseWidth], q_plot, <span class="string">'-o'</span>, <span class="string">'LineWidth'</span>, 2, <span class="string">'MarkerFaceColor'</span>, [0.2 0.4 0.7]);
yline(0, <span class="string">'k:'</span>);
yline(phi_q_ult, <span class="string">'Color'</span>, [0.3 0.6 0.3], <span class="string">'LineStyle'</span>, <span class="string">'--'</span>, <span class="string">'LineWidth'</span>, 1.2);

<span class="keyword">if</span> ~isnan(q_min) &amp;&amp; q_min &lt; 0
    text(geom.baseWidth * 0.8, min(q_plot) - 10, <span class="string">'Heel tension (q_{min} &lt; 0)'</span>, <span class="keyword">...</span>
        <span class="string">'Color'</span>, [0.6 0.1 0.1], <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
<span class="keyword">end</span>

xlabel(<span class="string">'Distance from toe (m)'</span>);
ylabel(<span class="string">'Bearing pressure (kPa)'</span>);
title(<span class="string">'Base Contact Pressure'</span>);
xlim([0, geom.baseWidth + 0.4]);
ylim([min([0, q_plot, phi_q_ult], [], <span class="string">'omitnan'</span>) - 20, max([q_plot, phi_q_ult], [], <span class="string">'omitnan'</span>) + 20]);
legend({<span class="string">'Contact pressure (SLS)'</span>, <span class="string">'Zero'</span>, <span class="string">'Factored resistance (\phi q_{ult})'</span>}, <span class="string">'Location'</span>, <span class="string">'best'</span>);
</pre>
<img vspace="5" hspace="5" src="gutter_check_01.png" alt="" /> <img vspace="5" hspace="5" src="gutter_check_02.png" alt="" /> <h2 id="10">-------------------------------------------------------------------------</h2>
<pre>GUTTER STRUCTURAL ADEQUACY CHECK (CSA A23.3)
-------------------------------------------------------------------------</pre>
<pre class="codeinput">fprintf(<span class="string">'\n\nGutter Structural Adequacy Check per CSA A23.3\n'</span>);
fprintf(<span class="string">'==============================================\n\n'</span>);

<span class="comment">% Material properties for concrete and steel (CSA A23.3)</span>
gutter.fc_prime = 30;              <span class="comment">% MPa - specified compressive strength of concrete</span>
gutter.fy = 400;                   <span class="comment">% MPa - specified yield strength of reinforcement (Grade 400)</span>
gutter.Es = 200000;                <span class="comment">% MPa - modulus of elasticity of steel</span>
gutter.Ec = 4500 * sqrt(gutter.fc_prime);  <span class="comment">% MPa - modulus of elasticity of concrete (CSA A23.3-14, Cl. 8.6.2.2)</span>

<span class="comment">% Material resistance factors (CSA A23.3-14)</span>
gutter.phi_c = 0.65;               <span class="comment">% resistance factor for concrete</span>
gutter.phi_s = 0.85;               <span class="comment">% resistance factor for steel</span>

<span class="comment">% Geometric properties</span>
gutter.span = geom.gutter.horizWidth;     <span class="comment">% m - clear span of gutter</span>
gutter.thickness = geom.gutter.horizThk;  <span class="comment">% m - slab thickness</span>
gutter.width = 1.0;                       <span class="comment">% m - design width (per metre)</span>

<span class="comment">% Reinforcement details</span>
gutter.barSize = 15;               <span class="comment">% 15M bar</span>
gutter.spacing = 0.300;            <span class="comment">% m - 300mm spacing</span>
gutter.cover = 0.040;              <span class="comment">% m - 40mm clear cover (CSA A23.3-14, Table 10.6.1 for severe exposure)</span>

<span class="comment">% 15M bar properties (CSA A23.3)</span>
gutter.Ab = 200;                   <span class="comment">% mm^2 - area of 15M bar</span>
gutter.db = 16;                    <span class="comment">% mm - nominal diameter of 15M bar</span>

<span class="comment">% Calculate effective depth</span>
gutter.d = gutter.thickness - gutter.cover - gutter.db/(2*1000);  <span class="comment">% m</span>

<span class="comment">% Steel area per metre width</span>
gutter.As = gutter.Ab * (gutter.width / gutter.spacing);  <span class="comment">% mm^2/m</span>

fprintf(<span class="string">'Gutter Geometry:\n'</span>);
fprintf(<span class="string">'  Span:                   %.3f m\n'</span>, gutter.span);
fprintf(<span class="string">'  Thickness:              %.0f mm\n'</span>, gutter.thickness * 1000);
fprintf(<span class="string">'  Effective depth (d):    %.0f mm\n'</span>, gutter.d * 1000);
fprintf(<span class="string">'  Reinforcement:          15M @ %.0f mm\n'</span>, gutter.spacing * 1000);
fprintf(<span class="string">'  As provided:            %.0f mm²/m\n'</span>, gutter.As);
fprintf(<span class="string">'  Cover:                  %.0f mm\n\n'</span>, gutter.cover * 1000);

<span class="comment">% Loading on gutter (simplified - self-weight + water weight)</span>
gutter.DL = mat.gammaConcrete * gutter.thickness;  <span class="comment">% kN/m² - dead load (self-weight)</span>
gutter.waterDepthInGutter = 0.0;                 <span class="comment">% m - assumed water depth in gutter (200mm)</span>
gutter.LL = mat.gammaWater * gutter.waterDepthInGutter;  <span class="comment">% kN/m² - live load (water)</span>

<span class="comment">% Load factors (CSA A23.3-14, Cl. 8.3.2)</span>
gutter.alphaD = 1.25;              <span class="comment">% dead load factor</span>
gutter.alphaL = 1.5;               <span class="comment">% live load factor</span>

<span class="comment">% Factored load per metre width</span>
gutter.wf = (gutter.alphaD * gutter.DL + gutter.alphaL * gutter.LL) * gutter.width;  <span class="comment">% kN/m</span>

fprintf(<span class="string">'Loading:\n'</span>);
fprintf(<span class="string">'  Dead load (DL):         %.2f kN/m²\n'</span>, gutter.DL);
fprintf(<span class="string">'  Live load (LL):         %.2f kN/m² (water in gutter)\n'</span>, gutter.LL);
fprintf(<span class="string">'  Factored load (wf):     %.2f kN/m\n\n'</span>, gutter.wf);
</pre>
<pre class="codeoutput">
Gutter Structural Adequacy Check per CSA A23.3
==============================================

Gutter Geometry:
  Span:                   1.000 m
  Thickness:              150 mm
  Effective depth (d):    102 mm
  Reinforcement:          15M @ 300 mm
  As provided:            667 mm²/m
  Cover:                  40 mm

Loading:
  Dead load (DL):         3.75 kN/m²
  Live load (LL):         0.00 kN/m² (water in gutter)
  Factored load (wf):     4.69 kN/m

</pre>
<h2 id="11">--- MOMENT CHECK ---</h2>
<pre class="codeinput">fprintf(<span class="string">'--- MOMENT CHECK (CSA A23.3-14, Cl. 10.1.7) ---\n'</span>);

<span class="comment">% Maximum factored moment (simply supported or cantilever from stem)</span>
<span class="comment">% Assuming cantilever from stem support</span>
gutter.Mf = gutter.wf * gutter.span^2 / 2;  <span class="comment">% kN·m/m</span>

fprintf(<span class="string">'  Factored moment (Mf):   %.2f kN·m/m\n'</span>, gutter.Mf);

<span class="comment">% Calculate balanced reinforcement ratio (CSA A23.3-14, Cl. 10.5.2)</span>
gutter.beta1 = max(0.67, 0.97 - 0.0025 * gutter.fc_prime);  <span class="comment">% stress block parameter</span>
gutter.eps_y = gutter.fy / gutter.Es;                        <span class="comment">% yield strain</span>
gutter.eps_cu = 0.0035;                                       <span class="comment">% ultimate concrete strain (CSA A23.3-14)</span>
gutter.cb_balanced = gutter.eps_cu / (gutter.eps_cu + gutter.eps_y) * gutter.d;  <span class="comment">% balanced neutral axis depth</span>
gutter.rho_balanced = gutter.phi_c / gutter.phi_s * 0.85 * gutter.fc_prime * gutter.beta1 / gutter.fy * <span class="keyword">...</span>
                      gutter.cb_balanced / gutter.d;

<span class="comment">% Actual reinforcement ratio</span>
gutter.rho = gutter.As / (gutter.width * 1000 * gutter.d * 1000);  <span class="comment">% convert to consistent units</span>

fprintf(<span class="string">'  Reinforcement ratio (ρ):         %.4f\n'</span>, gutter.rho);
fprintf(<span class="string">'  Balanced ratio (ρ_balanced):     %.4f\n'</span>, gutter.rho_balanced);

<span class="keyword">if</span> gutter.rho &gt; gutter.rho_balanced
    fprintf(<span class="string">'  WARNING: Over-reinforced section (compression failure)\n'</span>);
<span class="keyword">end</span>

<span class="comment">% Calculate factored moment resistance (CSA A23.3-14, Cl. 10.10)</span>
<span class="comment">% Assume rectangular section with tension reinforcement only</span>
gutter.a = gutter.phi_s * gutter.As * gutter.fy / (gutter.phi_c * 0.85 * gutter.fc_prime * gutter.width * 1000);  <span class="comment">% mm</span>
gutter.c = gutter.a / gutter.beta1;  <span class="comment">% mm - neutral axis depth</span>

<span class="comment">% Check if section is tension-controlled (c ≤ 0.375d per CSA)</span>
<span class="keyword">if</span> gutter.c &lt;= 0.375 * gutter.d * 1000
    fprintf(<span class="string">'  Section is tension-controlled (c/d = %.3f ≤ 0.375)\n'</span>, gutter.c / (gutter.d * 1000));
<span class="keyword">else</span>
    fprintf(<span class="string">'  WARNING: Section may not be tension-controlled (c/d = %.3f &gt; 0.375)\n'</span>, gutter.c / (gutter.d * 1000));
<span class="keyword">end</span>

gutter.Mr = gutter.phi_s * gutter.As * gutter.fy * (gutter.d * 1000 - gutter.a / 2) / 1e6;  <span class="comment">% kN·m/m</span>

fprintf(<span class="string">'  Neutral axis depth (c):          %.1f mm\n'</span>, gutter.c);
fprintf(<span class="string">'  Moment resistance (Mr):          %.2f kN·m/m\n'</span>, gutter.Mr);
fprintf(<span class="string">'  Demand/Capacity (Mf/Mr):         %.3f\n'</span>, gutter.Mf / gutter.Mr);

<span class="keyword">if</span> gutter.Mf &lt;= gutter.Mr
    fprintf(<span class="string">'  ✓ MOMENT CHECK: PASS (Mf ≤ Mr)\n\n'</span>);
<span class="keyword">else</span>
    fprintf(<span class="string">'  ✗ MOMENT CHECK: FAIL (Mf &gt; Mr) - Increase reinforcement or thickness\n\n'</span>);
<span class="keyword">end</span>
</pre>
<pre class="codeoutput">--- MOMENT CHECK (CSA A23.3-14, Cl. 10.1.7) ---
  Factored moment (Mf):   2.34 kN·m/m
  Reinforcement ratio (ρ):         0.0065
  Balanced ratio (ρ_balanced):     0.0278
  Section is tension-controlled (c/d = 0.150 ≤ 0.375)
  Neutral axis depth (c):          15.3 mm
  Moment resistance (Mr):          21.57 kN·m/m
  Demand/Capacity (Mf/Mr):         0.109
  ✓ MOMENT CHECK: PASS (Mf ≤ Mr)

</pre>
<h2 id="12">--- SHEAR CHECK ---</h2>
<pre class="codeinput">fprintf(<span class="string">'--- SHEAR CHECK (CSA A23.3-14, Cl. 11.3) ---\n'</span>);

<span class="comment">% Maximum factored shear (at support)</span>
gutter.Vf = gutter.wf * gutter.span;  <span class="comment">% kN/m</span>

fprintf(<span class="string">'  Factored shear (Vf):             %.2f kN/m\n'</span>, gutter.Vf);

<span class="comment">% Concrete shear resistance (CSA A23.3-14, Cl. 11.3.4)</span>
<span class="comment">% For members without shear reinforcement</span>
gutter.lambda = 1.0;                  <span class="comment">% normal density concrete</span>
gutter.beta = 0.21;                   <span class="comment">% factor for simplified method</span>
gutter.Vc = gutter.phi_c * gutter.lambda * gutter.beta * sqrt(gutter.fc_prime) * <span class="keyword">...</span>
            gutter.width * 1000 * gutter.d * 1000 / 1000;  <span class="comment">% N -&gt; kN</span>

fprintf(<span class="string">'  Concrete shear resistance (Vc): %.2f kN/m\n'</span>, gutter.Vc);
fprintf(<span class="string">'  Demand/Capacity (Vf/Vc):         %.3f\n'</span>, gutter.Vf / gutter.Vc);

<span class="keyword">if</span> gutter.Vf &lt;= gutter.Vc
    fprintf(<span class="string">'  ✓ SHEAR CHECK: PASS (Vf ≤ Vc)\n'</span>);
    fprintf(<span class="string">'  No shear reinforcement required\n\n'</span>);
<span class="keyword">else</span>
    fprintf(<span class="string">'  ✗ SHEAR CHECK: FAIL (Vf &gt; Vc)\n'</span>);
    fprintf(<span class="string">'  Shear reinforcement required or increase thickness\n\n'</span>);
<span class="keyword">end</span>
</pre>
<pre class="codeoutput">--- SHEAR CHECK (CSA A23.3-14, Cl. 11.3) ---
  Factored shear (Vf):             4.69 kN/m
  Concrete shear resistance (Vc): 76.26 kN/m
  Demand/Capacity (Vf/Vc):         0.061
  ✓ SHEAR CHECK: PASS (Vf ≤ Vc)
  No shear reinforcement required

</pre>
<h2 id="13">--- DEFLECTION CHECK ---</h2>
<pre class="codeinput">fprintf(<span class="string">'--- DEFLECTION CHECK (CSA A23.3-14, Cl. 9.8) ---\n'</span>);

<span class="comment">% Service load (unfactored)</span>
gutter.ws = (gutter.DL + gutter.LL) * gutter.width;  <span class="comment">% kN/m</span>

<span class="comment">% Calculate cracking moment (CSA A23.3-14, Cl. 9.8.4.2)</span>
gutter.fr = 0.6 * gutter.lambda * sqrt(gutter.fc_prime);  <span class="comment">% MPa - modulus of rupture</span>
gutter.Ig = gutter.width * 1000 * (gutter.thickness * 1000)^3 / 12;  <span class="comment">% mm^4 - gross moment of inertia</span>
gutter.yt = gutter.thickness * 1000 / 2;  <span class="comment">% mm - distance from neutral axis to extreme tension fibre</span>
gutter.Mcr = gutter.fr * gutter.Ig / gutter.yt / 1e6;  <span class="comment">% kN·m/m - cracking moment</span>

fprintf(<span class="string">'  Service load (ws):               %.2f kN/m\n'</span>, gutter.ws);
fprintf(<span class="string">'  Cracking moment (Mcr):           %.2f kN·m/m\n'</span>, gutter.Mcr);

<span class="comment">% Service moment (cantilever)</span>
gutter.Ms = gutter.ws * gutter.span^2 / 2;  <span class="comment">% kN·m/m</span>

fprintf(<span class="string">'  Service moment (Ms):             %.2f kN·m/m\n'</span>, gutter.Ms);

<span class="comment">% Determine if section is cracked</span>
<span class="keyword">if</span> gutter.Ms &gt; gutter.Mcr
    fprintf(<span class="string">'  Section is CRACKED under service load\n'</span>);

    <span class="comment">% Calculate cracked moment of inertia (transformed section)</span>
    gutter.n = gutter.Es / gutter.Ec;  <span class="comment">% modular ratio</span>

    <span class="comment">% Solve for neutral axis of cracked section (kd)</span>
    <span class="comment">% Quadratic equation: (b/2)(kd)^2 = n*As*(d - kd)</span>
    gutter.k = sqrt(2 * gutter.rho * gutter.n + (gutter.rho * gutter.n)^2) - gutter.rho * gutter.n;
    gutter.kd = gutter.k * gutter.d * 1000;  <span class="comment">% mm</span>

    <span class="comment">% Cracked moment of inertia</span>
    gutter.Icr = gutter.width * 1000 * gutter.kd^3 / 3 + <span class="keyword">...</span>
                 gutter.n * gutter.As * (gutter.d * 1000 - gutter.kd)^2;  <span class="comment">% mm^4</span>

    <span class="comment">% Effective moment of inertia (CSA A23.3-14, Cl. 9.8.4.2)</span>
    gutter.Ie = (gutter.Mcr / gutter.Ms)^3 * gutter.Ig + <span class="keyword">...</span>
                (1 - (gutter.Mcr / gutter.Ms)^3) * gutter.Icr;

    fprintf(<span class="string">'  Effective moment of inertia (Ie): %.2e mm^4\n'</span>, gutter.Ie);
<span class="keyword">else</span>
    fprintf(<span class="string">'  Section is UNCRACKED under service load\n'</span>);
    gutter.Ie = gutter.Ig;
    fprintf(<span class="string">'  Using gross moment of inertia (Ig): %.2e mm^4\n'</span>, gutter.Ie);
<span class="keyword">end</span>

<span class="comment">% Calculate immediate deflection (cantilever)</span>
gutter.delta_i = gutter.ws * (gutter.span * 1000)^4 / (8 * gutter.Ec * gutter.Ie);  <span class="comment">% mm</span>

fprintf(<span class="string">'  Immediate deflection:            %.2f mm\n'</span>, gutter.delta_i);

<span class="comment">% Long-term deflection (CSA A23.3-14, Cl. 9.8.4.3)</span>
gutter.xi = 2.0;                   <span class="comment">% time-dependent factor (5 years or more)</span>
gutter.rho_prime = 0;              <span class="comment">% compression reinforcement ratio (assumed zero)</span>
gutter.lambda_delta = gutter.xi / (1 + 50 * gutter.rho_prime);  <span class="comment">% deflection multiplier</span>

gutter.delta_total = gutter.delta_i * (1 + gutter.lambda_delta);  <span class="comment">% mm</span>

fprintf(<span class="string">'  Long-term multiplier (λ):        %.2f\n'</span>, gutter.lambda_delta);
fprintf(<span class="string">'  Total deflection (δ_total):      %.2f mm\n'</span>, gutter.delta_total);

<span class="comment">% Deflection limit (CSA A23.3-14, Table 9.3)</span>
gutter.delta_limit = gutter.span * 1000 / 240;  <span class="comment">% mm (for members supporting non-structural elements)</span>

fprintf(<span class="string">'  Deflection limit (L/240):        %.2f mm\n'</span>, gutter.delta_limit);
fprintf(<span class="string">'  Demand/Limit:                    %.3f\n'</span>, gutter.delta_total / gutter.delta_limit);

<span class="keyword">if</span> gutter.delta_total &lt;= gutter.delta_limit
    fprintf(<span class="string">'  ✓ DEFLECTION CHECK: PASS (δ ≤ L/240)\n\n'</span>);
<span class="keyword">else</span>
    fprintf(<span class="string">'  ✗ DEFLECTION CHECK: FAIL (δ &gt; L/240) - Consider increasing thickness\n\n'</span>);
<span class="keyword">end</span>

fprintf(<span class="string">'--- END OF GUTTER STRUCTURAL ADEQUACY CHECK ---\n\n'</span>);
</pre>
<pre class="codeoutput">--- DEFLECTION CHECK (CSA A23.3-14, Cl. 9.8) ---
  Service load (ws):               3.75 kN/m
  Cracking moment (Mcr):           12.32 kN·m/m
  Service moment (Ms):             1.88 kN·m/m
  Section is UNCRACKED under service load
  Using gross moment of inertia (Ig): 2.81e+08 mm^4
  Immediate deflection:            0.07 mm
  Long-term multiplier (λ):        2.00
  Total deflection (δ_total):      0.20 mm
  Deflection limit (L/240):        4.17 mm
  Demand/Limit:                    0.049
  ✓ DEFLECTION CHECK: PASS (δ ≤ L/240)

--- END OF GUTTER STRUCTURAL ADEQUACY CHECK ---

</pre>
<h2 id="14">-------------------------------------------------------------------------</h2>
<pre>LOCAL FUNCTION(S)
-------------------------------------------------------------------------</pre>
<pre class="codeinput"><span class="keyword">function</span> components = addComponent(components, name, weight, leverArm, notes)
<span class="comment">% addComponent helper to append gravity load data to the component list</span>
    component.Name     = name;
    component.Weight   = weight;
    component.LeverArm = leverArm;
    component.Moment   = weight * leverArm;
    component.Notes    = notes;
    components = [components; component];
<span class="keyword">end</span>
</pre>
<p class="footer">
<br />
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2025b</a>
<br />
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% WATER_RETAINING_WALL_CSA
% CSA-based stability analysis for a water-retaining wall section.
% Checks overturning, sliding, and bearing capacity for the supplied geometry
% and hydrostatic loading. All forces are reported per metre length of wall.
%
% Coordinate system: toe edge at x = 0, positive x runs toward the heel.
% Several geometric values (e.g., stem and base thickness) are assumed and
% should be updated if project-specific data are available.

clear; close all; clc;

mm = 1e-3;

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  INPUT PARAMETERS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

% Geometry (metres unless noted)
geom.stemHeight = 3050 * mm;
geom.heelWidth  = 1300 * mm;
geom.toeWidth   = 610  * mm;
geom.stemThk    = 0.35;         % average constant thickness
geom.baseThk    = 0.4;         % footing thickness
geom.keyWidth   = 350  * mm;
geom.keyDepth   = 370  * mm;

geom.gutter.offsetBelowTop = 400 * mm;
geom.gutter.horizWidth     = 1000 * mm;
geom.gutter.horizThk       = 150 * mm;
geom.gutter.vertHeight     = 290 * mm;
geom.gutter.vertThk        = 150 * mm;

geom.roof.thk           = 250 * mm;
geom.roof.tributarySpan = 3.0; % m

% Optional heel floor slab weight (set thickness > 0 to include)
geom.floorSlabThk   = 0.0;      % m
geom.floorSlabWidth = geom.heelWidth;

% Hydrostatic loading
loads.waterDepth = 0.0 * mm;   % measured from heel slab surface

% Material properties
mat.gammaConcrete = 25.0;       % kN/m^3
mat.gammaWater    = 9.81;       % kN/m^3
mat.gammaSoil     = 19.0;       % kN/m^3
mat.phi           = deg2rad(31);
mat.delta         = deg2rad(15);

% CSA target factors of safety(temporary works)
criteria.overturning = 1.20;
criteria.sliding     = 1.20;
criteria.bearing     = 2.0;

ls.phi_bearing = 0.5;
ls.gamma_dead  = 1.25;
ls.gamma_hydro = 1.00;

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  DERIVED GEOMETRY
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

geom.baseWidth        = geom.toeWidth + geom.heelWidth + geom.stemThk;
geom.stemCL           = geom.toeWidth + geom.stemThk/2;
geom.baseTopElevation = geom.baseThk;
geom.stemLeft         = geom.stemCL - geom.stemThk/2;
geom.stemRight        = geom.stemCL + geom.stemThk/2;

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  GRAVITY LOAD COMPONENTS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

components = struct('Name', {}, 'Weight', {}, 'LeverArm', {}, 'Moment', {}, 'Notes', {});

components = addComponent(components, "Base slab", ...
    mat.gammaConcrete * geom.baseWidth * geom.baseThk, geom.baseWidth / 2, ...
    "Footing self-weight");

components = addComponent(components, "Shear key", ...
    mat.gammaConcrete * geom.keyWidth * geom.keyDepth, geom.stemCL, ...
    "Key volume below footing");

components = addComponent(components, "Stem", ...
    mat.gammaConcrete * geom.stemThk * geom.stemHeight, geom.stemCL, ...
    "Rectangular stem");

components = addComponent(components, "Gutter (horizontal)", ...
    mat.gammaConcrete * geom.gutter.horizWidth * geom.gutter.horizThk, ...
    geom.stemCL - geom.gutter.horizWidth / 2, ...
    "Toe-side gutter slab");

components = addComponent(components, "Gutter (vertical)", ...
    mat.gammaConcrete * geom.gutter.vertHeight * geom.gutter.vertThk, ...
    geom.stemCL - geom.gutter.horizWidth + geom.gutter.vertThk / 2, ...
    "Toe-side curb");

components = addComponent(components, "Roof slab tributary load", ...
    mat.gammaConcrete * geom.roof.thk * geom.roof.tributarySpan, geom.stemCL, ...
    "Roof weight carried by stem");

if geom.floorSlabThk > 0
    components = addComponent(components, "Heel floor slab (optional)", ...
        mat.gammaConcrete * geom.floorSlabThk * geom.floorSlabWidth, ...
        geom.stemCL + geom.heelWidth / 2, ...
        "Adjust thickness if present");
end

weights     = [components.Weight]';
leverArms   = [components.LeverArm]';
moments     = [components.Moment]';

W_total     = sum(weights);
M_resisting = sum(moments);

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  HYDROSTATIC ACTIONS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

hydro.thrust = 0.5 * mat.gammaWater * loads.waterDepth^2;            % kN/m
hydro.arm    = geom.baseTopElevation + loads.waterDepth / 3;          % m
hydro.moment = hydro.thrust * hydro.arm;                              % kN·m/m

V_net = W_total;                                                       % kN/m (downwards positive)

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  STABILITY CHECKS (CSA)
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

FS_overturning = M_resisting / hydro.moment;

friction_resistance = V_net * tan(mat.delta);
Kp = tan(pi/4 + mat.phi/2)^2;
passive_resistance = 0.5 * Kp * mat.gammaSoil * geom.keyDepth^2 * geom.keyWidth;

FS_sliding = (friction_resistance + passive_resistance) / hydro.thrust;

M_net_about_toe = M_resisting - hydro.moment;

if V_net <= 0
    warning('Net vertical load is non-positive. Sliding and bearing checks are invalid.');
    x_resultant  = NaN;
    eccentricity = NaN;
    q_avg        = NaN;
    q_toe        = NaN;
    q_heel       = NaN;
else
    x_resultant  = M_net_about_toe / V_net;                  % m from toe
    eccentricity = geom.baseWidth / 2 - x_resultant;         % +ve toward toe
    q_avg        = V_net / geom.baseWidth;                   % kPa
    q_toe        = q_avg * (1 + 6 * eccentricity / geom.baseWidth);
    q_heel       = q_avg * (1 - 6 * eccentricity / geom.baseWidth);
end

W_uls              = ls.gamma_dead * W_total;
M_resisting_uls    = ls.gamma_dead * M_resisting;
hydro_uls.thrust   = ls.gamma_hydro * hydro.thrust;
hydro_uls.moment   = ls.gamma_hydro * hydro.moment;
V_net_uls          = W_uls;
M_net_about_toe_uls = M_resisting_uls - hydro_uls.moment;

if V_net_uls <= 0
    x_resultant_uls  = NaN;
    eccentricity_uls = NaN;
    q_avg_uls        = NaN;
    q_toe_uls        = NaN;
    q_heel_uls       = NaN;
else
    x_resultant_uls  = M_net_about_toe_uls / V_net_uls;
    eccentricity_uls = geom.baseWidth / 2 - x_resultant_uls;
    q_avg_uls        = V_net_uls / geom.baseWidth;
    q_toe_uls        = q_avg_uls * (1 + 6 * eccentricity_uls / geom.baseWidth);
    q_heel_uls       = q_avg_uls * (1 - 6 * eccentricity_uls / geom.baseWidth);
end

q_pair = [q_toe, q_heel];
valid_q = q_pair(~isnan(q_pair));
if isempty(valid_q)
    q_max = NaN;
    q_min = NaN;
else
    q_max = max(valid_q);
    q_min = min(valid_q);
end

Nq     = exp(pi * tan(mat.phi)) * tan(pi/4 + mat.phi/2)^2;
Ngamma = 2 * (Nq + 1) * tan(mat.phi);

% ULS effective width method (CFEM): no-tension, use B_eff = B - 2|e_uls|
if isnan(eccentricity_uls)
    B_eff_uls = NaN;
    q_dem_uls = NaN;
    phi_q_ult = NaN;
else
    B_eff_uls = max(geom.baseWidth - 2 * abs(eccentricity_uls), 1e-6);
    q_ult_eff = 0.5 * mat.gammaSoil * B_eff_uls * Ngamma;   % kPa
    phi_q_ult = ls.phi_bearing * q_ult_eff;                 % kPa
    q_dem_uls = V_net_uls / B_eff_uls;                      % kPa
end

% Also report ULS linear pressures (may show tension if e_uls > B/6)
if isnan(q_toe_uls) || isnan(q_heel_uls)
    q_max_uls = NaN;
    q_min_uls = NaN;
else
    q_max_uls = max([q_toe_uls, q_heel_uls]);
    q_min_uls = min([q_toe_uls, q_heel_uls]);
end

if isnan(q_dem_uls) || q_dem_uls <= 0
    FS_bearing = NaN;
else
    FS_bearing = phi_q_ult / q_dem_uls;
end

if isnan(eccentricity)
    within_middle_third = false;
else
    within_middle_third = abs(eccentricity) <= geom.baseWidth / 6;
end

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  TABULATED RESULTS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

componentTable = table(string({components.Name})', weights, leverArms, moments, string({components.Notes})', ...
    'VariableNames', {'Component', 'Weight_kN_per_m', 'LeverArm_m', 'Moment_kNm_per_m', 'Notes'});

FS_values   = [FS_overturning; FS_sliding; FS_bearing];
FS_required = [criteria.overturning; criteria.sliding; 1.0];
statusStr   = repmat("PASS", size(FS_values));
statusStr(FS_values < FS_required) = "CHECK";

resultsTable = table(["Overturning"; "Sliding"; "Bearing"], FS_values, FS_required, statusStr, ...
    'VariableNames', {'Check', 'FS_Computed', 'FS_Required', 'Status'});

bearingTable = table(q_toe, q_heel, q_avg, q_min, q_max, q_toe_uls, q_heel_uls, q_max_uls, B_eff_uls, q_dem_uls, phi_q_ult, within_middle_third, ...
    'VariableNames', {'q_toe_SLS_kPa', 'q_heel_SLS_kPa', 'q_avg_SLS_kPa', 'q_min_SLS_kPa', 'q_max_SLS_kPa', ...
                      'q_toe_ULS_kPa', 'q_heel_ULS_kPa', 'q_max_ULS_kPa', 'B_eff_ULS_m', 'q_dem_ULS_kPa', 'phi_q_ult_kPa', 'WithinMiddleThird'});

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  CONSOLE OUTPUT
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

fprintf('\nCSA Water-Retaining Wall Stability Check (per metre length)\n');
fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-\n');
fprintf('Toe width                : %.3f m\n', geom.toeWidth);
fprintf('Heel width               : %.3f m\n', geom.heelWidth);
fprintf('Overall base width       : %.3f m\n', geom.baseWidth);
fprintf('Stem height              : %.3f m\n', geom.stemHeight);
fprintf('Water depth at heel      : %.3f m\n', loads.waterDepth);
fprintf('Assumed base thickness   : %.0f mm\n', geom.baseThk * 1e3);
fprintf('Assumed stem thickness   : %.0f mm\n\n', geom.stemThk * 1e3);

fprintf('Total dead load          : %.2f kN/m\n', W_total);
fprintf('Hydrostatic thrust       : %.2f kN/m\n', hydro.thrust);
fprintf('Net vertical load        : %.2f kN/m\n\n', V_net);

disp(componentTable);

fprintf('Stability Factors of Safety\n');
fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-\n');
disp(resultsTable);

fprintf('Bearing summary (toe positive)\n');
fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-\n');
disp(bearingTable);

fprintf('Resultant from toe        : %.3f m\n', x_resultant);
fprintf('Eccentricity (toe +ve)    : %.3f m (limit %.3f m)\n', eccentricity, geom.baseWidth/6);

if FS_overturning < criteria.overturning
    fprintf('WARNING: Overturning FS below CSA minimum (%.2f < %.2f).\n', FS_overturning, criteria.overturning);
end
if FS_sliding < criteria.sliding
    fprintf('WARNING: Sliding FS below CSA minimum (%.2f < %.2f).\n', FS_sliding, criteria.sliding);
end
if FS_bearing < 1.0
    fprintf('WARNING: Bearing ULS check not satisfied (FS = %.2f < 1.00). Factored demand exceeds factored resistance.\n', FS_bearing);
end
if ~within_middle_third
    fprintf('WARNING: Resultant lies outside the middle third; heel tension likely.\n');
end
if ~isnan(q_min) && q_min < 0
    fprintf('WARNING: Heel contact pressure negative (q_{min} = %.2f kPa). Revise geometry/loading.\n', q_min);
end

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  VISUALISATIONS
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

figure('Name', 'Wall Geometry & Hydrostatics', 'Color', 'w');
hold on; axis equal;

% Base slab
basePoly = [0, 0;
            geom.baseWidth, 0;
            geom.baseWidth, geom.baseTopElevation;
            0, geom.baseTopElevation];
patch(basePoly(:,1), basePoly(:,2), [0.85 0.85 0.88], 'EdgeColor', 'k');

% Shear key
keyLeft  = geom.stemCL - geom.keyWidth/2;
keyRight = geom.stemCL + geom.keyWidth/2;
keyPoly = [keyLeft, 0;
           keyRight, 0;
           keyRight, -geom.keyDepth;
           keyLeft, -geom.keyDepth];
patch(keyPoly(:,1), keyPoly(:,2), [0.75 0.75 0.80], 'EdgeColor', 'k');

% Stem
stemPoly = [geom.stemLeft,  geom.baseTopElevation;
            geom.stemRight, geom.baseTopElevation;
            geom.stemRight, geom.baseTopElevation + geom.stemHeight;
            geom.stemLeft,  geom.baseTopElevation + geom.stemHeight];
patch(stemPoly(:,1), stemPoly(:,2), [0.90 0.90 0.94], 'EdgeColor', 'k');

% Gutter horizontal slab (toe side)
gutterTop    = geom.baseTopElevation + geom.stemHeight - geom.gutter.offsetBelowTop;
gutterBottom = gutterTop - geom.gutter.horizThk;
gutterLeft   = geom.stemCL - geom.gutter.horizWidth;
gutterRight  = geom.stemCL;
gutterHPoly  = [gutterLeft, gutterBottom;
                gutterRight, gutterBottom;
                gutterRight, gutterTop;
                gutterLeft, gutterTop];
patch(gutterHPoly(:,1), gutterHPoly(:,2), [0.80 0.88 0.90], 'EdgeColor', 'k');

% Gutter vertical curb
curbBottom = gutterTop;
curbTop    = gutterTop + geom.gutter.vertHeight;
curbLeft   = gutterLeft;
curbRight  = gutterLeft + geom.gutter.vertThk;
curbPoly   = [curbLeft, curbBottom;
              curbRight, curbBottom;
              curbRight, curbTop;
              curbLeft, curbTop];
patch(curbPoly(:,1), curbPoly(:,2), [0.78 0.86 0.88], 'EdgeColor', 'k');

% Water retained on heel side
waterTop = geom.baseTopElevation + loads.waterDepth;
waterPoly = [geom.stemRight,           geom.baseTopElevation;
             geom.stemRight,           waterTop;
             geom.stemRight + 0.35,    waterTop;
             geom.stemRight + 0.35,    geom.baseTopElevation];
patch(waterPoly(:,1), waterPoly(:,2), [0.70 0.80 0.95], 'FaceAlpha', 0.6, 'EdgeColor', [0.3 0.4 0.7]);

% Hydrostatic pressure diagram
pressureScale = 0.012; % m per kPa for plotting
pressureAtBase = mat.gammaWater * loads.waterDepth;
pressurePoly = [geom.stemRight,                               geom.baseTopElevation;
                geom.stemRight + pressureAtBase * pressureScale, geom.baseTopElevation;
                geom.stemRight,                               waterTop];
patch(pressurePoly(:,1), pressurePoly(:,2), [0.40 0.55 0.90], 'FaceAlpha', 0.35, 'EdgeColor', 'none');
plot([geom.stemRight, geom.stemRight], [geom.baseTopElevation, waterTop], 'b', 'LineWidth', 1.2);

% Resultant location marker
if ~isnan(x_resultant)
    plot([x_resultant, x_resultant], [-geom.keyDepth, geom.baseTopElevation], 'rREPLACE_WITH_DASH_DASH', 'LineWidth', 1.2);
    text(x_resultant, -geom.keyDepth - 0.05, sprintf('Resultant %.3f m from toe', x_resultant), ...
        'Color', 'r', 'HorizontalAlignment', 'center');
end

title('Wall Elevation & Hydrostatic Actions');
xlabel('Horizontal distance from toe (m)');
ylabel('Elevation (m)');
grid on;
xlim([gutterLeft - 0.4, geom.baseWidth + 0.5]);
ylim([-geom.keyDepth - 0.2, geom.baseTopElevation + geom.stemHeight + 0.4]);

% Stability summary plots REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
figure('Name', 'CSA Stability Summary', 'Color', 'w');
tl = tiledlayout(1,2, 'TileSpacing', 'compact', 'Padding', 'compact');

% Factors of safety bar chart
nexttile(tl, 1);
barData = [FS_values FS_required];
hb = bar(1:3, barData, 'grouped');
hb(1).FaceColor = [0.55 0.75 0.55];
hb(2).FaceColor = [0.85 0.60 0.60];
hold on; grid on;

for k = 1:numel(hb)
    xPts = hb(k).XEndPoints;
    yVals = hb(k).YData;
    for j = 1:numel(xPts)
        switch k
            case 1
                labelText = sprintf('%.2f', yVals(j));
                labelColor = [0 0 0];
                labelWeight = 'bold';
            case 2
                labelText = sprintf('Req %.2f', yVals(j));
                labelColor = [0.6 0.1 0.1];
                labelWeight = 'normal';
        end
        text(xPts(j), yVals(j) + 0.05, labelText, 'HorizontalAlignment', 'center', ...
            'Color', labelColor, 'FontWeight', labelWeight);
    end
end

set(gca, 'XTick', 1:3, 'XTickLabel', resultsTable.Check);
ylabel('Factor of Safety');
title('Factors of Safety vs CSA Targets');
legend({'Computed FS', 'CSA Target'}, 'Location', 'northwest');

% Bearing pressure profile
nexttile(tl, 2);
hold on; grid on;

if all(isnan(q_pair))
    q_plot = [0, 0];
else
    q_plot = [q_toe, q_heel];
end

plot([0, geom.baseWidth], q_plot, '-o', 'LineWidth', 2, 'MarkerFaceColor', [0.2 0.4 0.7]);
yline(0, 'k:');
yline(phi_q_ult, 'Color', [0.3 0.6 0.3], 'LineStyle', 'REPLACE_WITH_DASH_DASH', 'LineWidth', 1.2);

if ~isnan(q_min) && q_min < 0
    text(geom.baseWidth * 0.8, min(q_plot) - 10, 'Heel tension (q_{min} < 0)', ...
        'Color', [0.6 0.1 0.1], 'FontWeight', 'bold');
end

xlabel('Distance from toe (m)');
ylabel('Bearing pressure (kPa)');
title('Base Contact Pressure');
xlim([0, geom.baseWidth + 0.4]);
ylim([min([0, q_plot, phi_q_ult], [], 'omitnan') - 20, max([q_plot, phi_q_ult], [], 'omitnan') + 20]);
legend({'Contact pressure (SLS)', 'Zero', 'Factored resistance (\phi q_{ult})'}, 'Location', 'best');

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  GUTTER STRUCTURAL ADEQUACY CHECK (CSA A23.3)
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

fprintf('\n\nGutter Structural Adequacy Check per CSA A23.3\n');
fprintf('==============================================\n\n');

% Material properties for concrete and steel (CSA A23.3)
gutter.fc_prime = 30;              % MPa - specified compressive strength of concrete
gutter.fy = 400;                   % MPa - specified yield strength of reinforcement (Grade 400)
gutter.Es = 200000;                % MPa - modulus of elasticity of steel
gutter.Ec = 4500 * sqrt(gutter.fc_prime);  % MPa - modulus of elasticity of concrete (CSA A23.3-14, Cl. 8.6.2.2)

% Material resistance factors (CSA A23.3-14)
gutter.phi_c = 0.65;               % resistance factor for concrete
gutter.phi_s = 0.85;               % resistance factor for steel

% Geometric properties
gutter.span = geom.gutter.horizWidth;     % m - clear span of gutter
gutter.thickness = geom.gutter.horizThk;  % m - slab thickness
gutter.width = 1.0;                       % m - design width (per metre)

% Reinforcement details
gutter.barSize = 15;               % 15M bar
gutter.spacing = 0.300;            % m - 300mm spacing
gutter.cover = 0.040;              % m - 40mm clear cover (CSA A23.3-14, Table 10.6.1 for severe exposure)

% 15M bar properties (CSA A23.3)
gutter.Ab = 200;                   % mm^2 - area of 15M bar
gutter.db = 16;                    % mm - nominal diameter of 15M bar

% Calculate effective depth
gutter.d = gutter.thickness - gutter.cover - gutter.db/(2*1000);  % m

% Steel area per metre width
gutter.As = gutter.Ab * (gutter.width / gutter.spacing);  % mm^2/m

fprintf('Gutter Geometry:\n');
fprintf('  Span:                   %.3f m\n', gutter.span);
fprintf('  Thickness:              %.0f mm\n', gutter.thickness * 1000);
fprintf('  Effective depth (d):    %.0f mm\n', gutter.d * 1000);
fprintf('  Reinforcement:          15M @ %.0f mm\n', gutter.spacing * 1000);
fprintf('  As provided:            %.0f mm²/m\n', gutter.As);
fprintf('  Cover:                  %.0f mm\n\n', gutter.cover * 1000);

% Loading on gutter (simplified - self-weight + water weight)
gutter.DL = mat.gammaConcrete * gutter.thickness;  % kN/m² - dead load (self-weight)
gutter.waterDepthInGutter = 0.0;                 % m - assumed water depth in gutter (200mm)
gutter.LL = mat.gammaWater * gutter.waterDepthInGutter;  % kN/m² - live load (water)

% Load factors (CSA A23.3-14, Cl. 8.3.2)
gutter.alphaD = 1.25;              % dead load factor
gutter.alphaL = 1.5;               % live load factor

% Factored load per metre width
gutter.wf = (gutter.alphaD * gutter.DL + gutter.alphaL * gutter.LL) * gutter.width;  % kN/m

fprintf('Loading:\n');
fprintf('  Dead load (DL):         %.2f kN/m²\n', gutter.DL);
fprintf('  Live load (LL):         %.2f kN/m² (water in gutter)\n', gutter.LL);
fprintf('  Factored load (wf):     %.2f kN/m\n\n', gutter.wf);

%% REPLACE_WITH_DASH_DASH- MOMENT CHECK REPLACE_WITH_DASH_DASH-
fprintf('REPLACE_WITH_DASH_DASH- MOMENT CHECK (CSA A23.3-14, Cl. 10.1.7) REPLACE_WITH_DASH_DASH-\n');

% Maximum factored moment (simply supported or cantilever from stem)
% Assuming cantilever from stem support
gutter.Mf = gutter.wf * gutter.span^2 / 2;  % kN·m/m

fprintf('  Factored moment (Mf):   %.2f kN·m/m\n', gutter.Mf);

% Calculate balanced reinforcement ratio (CSA A23.3-14, Cl. 10.5.2)
gutter.beta1 = max(0.67, 0.97 - 0.0025 * gutter.fc_prime);  % stress block parameter
gutter.eps_y = gutter.fy / gutter.Es;                        % yield strain
gutter.eps_cu = 0.0035;                                       % ultimate concrete strain (CSA A23.3-14)
gutter.cb_balanced = gutter.eps_cu / (gutter.eps_cu + gutter.eps_y) * gutter.d;  % balanced neutral axis depth
gutter.rho_balanced = gutter.phi_c / gutter.phi_s * 0.85 * gutter.fc_prime * gutter.beta1 / gutter.fy * ...
                      gutter.cb_balanced / gutter.d;

% Actual reinforcement ratio
gutter.rho = gutter.As / (gutter.width * 1000 * gutter.d * 1000);  % convert to consistent units

fprintf('  Reinforcement ratio (ρ):         %.4f\n', gutter.rho);
fprintf('  Balanced ratio (ρ_balanced):     %.4f\n', gutter.rho_balanced);

if gutter.rho > gutter.rho_balanced
    fprintf('  WARNING: Over-reinforced section (compression failure)\n');
end

% Calculate factored moment resistance (CSA A23.3-14, Cl. 10.10)
% Assume rectangular section with tension reinforcement only
gutter.a = gutter.phi_s * gutter.As * gutter.fy / (gutter.phi_c * 0.85 * gutter.fc_prime * gutter.width * 1000);  % mm
gutter.c = gutter.a / gutter.beta1;  % mm - neutral axis depth

% Check if section is tension-controlled (c ≤ 0.375d per CSA)
if gutter.c <= 0.375 * gutter.d * 1000
    fprintf('  Section is tension-controlled (c/d = %.3f ≤ 0.375)\n', gutter.c / (gutter.d * 1000));
else
    fprintf('  WARNING: Section may not be tension-controlled (c/d = %.3f > 0.375)\n', gutter.c / (gutter.d * 1000));
end

gutter.Mr = gutter.phi_s * gutter.As * gutter.fy * (gutter.d * 1000 - gutter.a / 2) / 1e6;  % kN·m/m

fprintf('  Neutral axis depth (c):          %.1f mm\n', gutter.c);
fprintf('  Moment resistance (Mr):          %.2f kN·m/m\n', gutter.Mr);
fprintf('  Demand/Capacity (Mf/Mr):         %.3f\n', gutter.Mf / gutter.Mr);

if gutter.Mf <= gutter.Mr
    fprintf('  ✓ MOMENT CHECK: PASS (Mf ≤ Mr)\n\n');
else
    fprintf('  ✗ MOMENT CHECK: FAIL (Mf > Mr) - Increase reinforcement or thickness\n\n');
end

%% REPLACE_WITH_DASH_DASH- SHEAR CHECK REPLACE_WITH_DASH_DASH-
fprintf('REPLACE_WITH_DASH_DASH- SHEAR CHECK (CSA A23.3-14, Cl. 11.3) REPLACE_WITH_DASH_DASH-\n');

% Maximum factored shear (at support)
gutter.Vf = gutter.wf * gutter.span;  % kN/m

fprintf('  Factored shear (Vf):             %.2f kN/m\n', gutter.Vf);

% Concrete shear resistance (CSA A23.3-14, Cl. 11.3.4)
% For members without shear reinforcement
gutter.lambda = 1.0;                  % normal density concrete
gutter.beta = 0.21;                   % factor for simplified method
gutter.Vc = gutter.phi_c * gutter.lambda * gutter.beta * sqrt(gutter.fc_prime) * ...
            gutter.width * 1000 * gutter.d * 1000 / 1000;  % N -> kN

fprintf('  Concrete shear resistance (Vc): %.2f kN/m\n', gutter.Vc);
fprintf('  Demand/Capacity (Vf/Vc):         %.3f\n', gutter.Vf / gutter.Vc);

if gutter.Vf <= gutter.Vc
    fprintf('  ✓ SHEAR CHECK: PASS (Vf ≤ Vc)\n');
    fprintf('  No shear reinforcement required\n\n');
else
    fprintf('  ✗ SHEAR CHECK: FAIL (Vf > Vc)\n');
    fprintf('  Shear reinforcement required or increase thickness\n\n');
end

%% REPLACE_WITH_DASH_DASH- DEFLECTION CHECK REPLACE_WITH_DASH_DASH-
fprintf('REPLACE_WITH_DASH_DASH- DEFLECTION CHECK (CSA A23.3-14, Cl. 9.8) REPLACE_WITH_DASH_DASH-\n');

% Service load (unfactored)
gutter.ws = (gutter.DL + gutter.LL) * gutter.width;  % kN/m

% Calculate cracking moment (CSA A23.3-14, Cl. 9.8.4.2)
gutter.fr = 0.6 * gutter.lambda * sqrt(gutter.fc_prime);  % MPa - modulus of rupture
gutter.Ig = gutter.width * 1000 * (gutter.thickness * 1000)^3 / 12;  % mm^4 - gross moment of inertia
gutter.yt = gutter.thickness * 1000 / 2;  % mm - distance from neutral axis to extreme tension fibre
gutter.Mcr = gutter.fr * gutter.Ig / gutter.yt / 1e6;  % kN·m/m - cracking moment

fprintf('  Service load (ws):               %.2f kN/m\n', gutter.ws);
fprintf('  Cracking moment (Mcr):           %.2f kN·m/m\n', gutter.Mcr);

% Service moment (cantilever)
gutter.Ms = gutter.ws * gutter.span^2 / 2;  % kN·m/m

fprintf('  Service moment (Ms):             %.2f kN·m/m\n', gutter.Ms);

% Determine if section is cracked
if gutter.Ms > gutter.Mcr
    fprintf('  Section is CRACKED under service load\n');
    
    % Calculate cracked moment of inertia (transformed section)
    gutter.n = gutter.Es / gutter.Ec;  % modular ratio
    
    % Solve for neutral axis of cracked section (kd)
    % Quadratic equation: (b/2)(kd)^2 = n*As*(d - kd)
    gutter.k = sqrt(2 * gutter.rho * gutter.n + (gutter.rho * gutter.n)^2) - gutter.rho * gutter.n;
    gutter.kd = gutter.k * gutter.d * 1000;  % mm
    
    % Cracked moment of inertia
    gutter.Icr = gutter.width * 1000 * gutter.kd^3 / 3 + ...
                 gutter.n * gutter.As * (gutter.d * 1000 - gutter.kd)^2;  % mm^4
    
    % Effective moment of inertia (CSA A23.3-14, Cl. 9.8.4.2)
    gutter.Ie = (gutter.Mcr / gutter.Ms)^3 * gutter.Ig + ...
                (1 - (gutter.Mcr / gutter.Ms)^3) * gutter.Icr;
    
    fprintf('  Effective moment of inertia (Ie): %.2e mm^4\n', gutter.Ie);
else
    fprintf('  Section is UNCRACKED under service load\n');
    gutter.Ie = gutter.Ig;
    fprintf('  Using gross moment of inertia (Ig): %.2e mm^4\n', gutter.Ie);
end

% Calculate immediate deflection (cantilever)
gutter.delta_i = gutter.ws * (gutter.span * 1000)^4 / (8 * gutter.Ec * gutter.Ie);  % mm

fprintf('  Immediate deflection:            %.2f mm\n', gutter.delta_i);

% Long-term deflection (CSA A23.3-14, Cl. 9.8.4.3)
gutter.xi = 2.0;                   % time-dependent factor (5 years or more)
gutter.rho_prime = 0;              % compression reinforcement ratio (assumed zero)
gutter.lambda_delta = gutter.xi / (1 + 50 * gutter.rho_prime);  % deflection multiplier

gutter.delta_total = gutter.delta_i * (1 + gutter.lambda_delta);  % mm

fprintf('  Long-term multiplier (λ):        %.2f\n', gutter.lambda_delta);
fprintf('  Total deflection (δ_total):      %.2f mm\n', gutter.delta_total);

% Deflection limit (CSA A23.3-14, Table 9.3)
gutter.delta_limit = gutter.span * 1000 / 240;  % mm (for members supporting non-structural elements)

fprintf('  Deflection limit (L/240):        %.2f mm\n', gutter.delta_limit);
fprintf('  Demand/Limit:                    %.3f\n', gutter.delta_total / gutter.delta_limit);

if gutter.delta_total <= gutter.delta_limit
    fprintf('  ✓ DEFLECTION CHECK: PASS (δ ≤ L/240)\n\n');
else
    fprintf('  ✗ DEFLECTION CHECK: FAIL (δ > L/240) - Consider increasing thickness\n\n');
end

fprintf('REPLACE_WITH_DASH_DASH- END OF GUTTER STRUCTURAL ADEQUACY CHECK REPLACE_WITH_DASH_DASH-\n\n');

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%  LOCAL FUNCTION(S)
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

function components = addComponent(components, name, weight, leverArm, notes)
% addComponent helper to append gravity load data to the component list
    component.Name     = name;
    component.Weight   = weight;
    component.LeverArm = leverArm;
    component.Moment   = weight * leverArm;
    component.Notes    = notes;
    components = [components; component];
end


##### SOURCE END #####
-->


</body></html>